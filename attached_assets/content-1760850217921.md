#!/bin/sh
\# shellcheck shell=dash
\# shellcheck disable=SC2039 # local is non-POSIX
#
\# Licensed under the MIT license
\# , at your
\# option. This file may not be copied, modified, or distributed
\# except according to those terms.

\# This runs on Unix shells like bash/dash/ksh/zsh. It uses the common \`local\`
\# extension. Note: Most shells limit \`local\` to 1 var per line, contra bash.

\# Some versions of ksh have no \`local\` keyword. Alias it to \`typeset\`, but
\# beware this makes variables global with f()-style function syntax in ksh93.
\# mksh has this alias by default.
has\_local() {
 # shellcheck disable=SC2034 # deliberately unused
 local \_has\_local
}

has\_local 2>/dev/null \|\| alias local=typeset

set -u

APP\_NAME="uv"
APP\_VERSION="0.9.4"
\# Look for GitHub Enterprise-style base URL first
if \[ -n "${UV\_INSTALLER\_GHE\_BASE\_URL:-}" \]; then
 INSTALLER\_BASE\_URL="$UV\_INSTALLER\_GHE\_BASE\_URL"
else
 INSTALLER\_BASE\_URL="${UV\_INSTALLER\_GITHUB\_BASE\_URL:-https://github.com}"
fi
if \[ -n "${UV\_DOWNLOAD\_URL:-}" \]; then
 ARTIFACT\_DOWNLOAD\_URL="$UV\_DOWNLOAD\_URL"
elif \[ -n "${INSTALLER\_DOWNLOAD\_URL:-}" \]; then
 ARTIFACT\_DOWNLOAD\_URL="$INSTALLER\_DOWNLOAD\_URL"
else
 ARTIFACT\_DOWNLOAD\_URL="${INSTALLER\_BASE\_URL}/astral-sh/uv/releases/download/0.9.4"
fi
if \[ -n "${UV\_PRINT\_VERBOSE:-}" \]; then
 PRINT\_VERBOSE="$UV\_PRINT\_VERBOSE"
else
 PRINT\_VERBOSE=${INSTALLER\_PRINT\_VERBOSE:-0}
fi
if \[ -n "${UV\_PRINT\_QUIET:-}" \]; then
 PRINT\_QUIET="$UV\_PRINT\_QUIET"
else
 PRINT\_QUIET=${INSTALLER\_PRINT\_QUIET:-0}
fi
if \[ -n "${UV\_NO\_MODIFY\_PATH:-}" \]; then
 NO\_MODIFY\_PATH="$UV\_NO\_MODIFY\_PATH"
else
 NO\_MODIFY\_PATH=${INSTALLER\_NO\_MODIFY\_PATH:-0}
fi
if \[ "${UV\_DISABLE\_UPDATE:-0}" = "1" \]; then
 INSTALL\_UPDATER=0
else
 INSTALL\_UPDATER=1
fi
UNMANAGED\_INSTALL="${UV\_UNMANAGED\_INSTALL:-}"
if \[ -n "${UNMANAGED\_INSTALL}" \]; then
 NO\_MODIFY\_PATH=1
 INSTALL\_UPDATER=0
fi
AUTH\_TOKEN="${UV\_GITHUB\_TOKEN:-}"

read -r RECEIPT <&2
 say\_verbose " from $\_url" 1>&2
 say\_verbose " to $\_file" 1>&2

 ensure mkdir -p "$\_dir"

 if ! downloader "$\_url" "$\_file"; then
 say "failed to download $\_url"
 say "this may be a standard network error, but it may also indicate"
 say "that $APP\_NAME's release process is not working. When in doubt"
 say "please feel free to open an issue!"
 exit 1
 fi

 if \[ -n "${\_checksum\_style:-}" \]; then
 verify\_checksum "$\_file" "$\_checksum\_style" "$\_checksum\_value"
 else
 say "no checksums to verify"
 fi

 # ...and then the updater, if it exists
 if \[ -n "$\_updater\_name" \] && \[ "$INSTALL\_UPDATER" = "1" \]; then
 local \_updater\_url="$ARTIFACT\_DOWNLOAD\_URL/$\_updater\_name"
 # This renames the artifact while doing the download, removing the
 # target triple and leaving just the appname-update format
 local \_updater\_file="$\_dir/$APP\_NAME-update"

 if ! downloader "$\_updater\_url" "$\_updater\_file"; then
 say "failed to download $\_updater\_url"
 say "this may be a standard network error, but it may also indicate"
 say "that $APP\_NAME's release process is not working. When in doubt"
 say "please feel free to open an issue!"
 exit 1
 fi

 # Add the updater to the list of binaries to install
 \_bins="$\_bins $APP\_NAME-update"
 fi

 # unpack the archive
 case "$\_zip\_ext" in
 ".zip")
 ensure unzip -q "$\_file" -d "$\_dir"
 ;;

 ".tar."\*)
 ensure tar xf "$\_file" --strip-components 1 -C "$\_dir"
 ;;
 \*)
 err "unknown archive format: $\_zip\_ext"
 ;;
 esac

 install "$\_dir" "$\_bins" "$\_libs" "$\_staticlibs" "$\_arch" "$@"
 local \_retval=$?
 if \[ "$\_retval" != 0 \]; then
 return "$\_retval"
 fi

 ignore rm -rf "$\_dir"

 # Install the install receipt
 if \[ "$INSTALL\_UPDATER" = "1" \]; then
 if ! mkdir -p "$RECEIPT\_HOME"; then
 err "unable to create receipt directory at $RECEIPT\_HOME"
 else
 echo "$RECEIPT" > "$RECEIPT\_HOME/$APP\_NAME-receipt.json"
 # shellcheck disable=SC2320
 local \_retval=$?
 fi
 else
 local \_retval=0
 fi

 return "$\_retval"
}

\# Replaces $HOME with the variable name for display to the user,
\# only if $HOME is defined.
replace\_home() {
 local \_str="$1"

 if \[ -n "${HOME:-}" \]; then
 echo "$\_str" \| sed "s,$HOME,\\$HOME,"
 else
 echo "$\_str"
 fi
}

json\_binary\_aliases() {
 local \_arch="$1"

 case "$\_arch" in
 "aarch64-apple-darwin")
 echo '{}'
 ;;
 "aarch64-pc-windows-gnu")
 echo '{}'
 ;;
 "aarch64-unknown-linux-gnu")
 echo '{}'
 ;;
 "aarch64-unknown-linux-musl-dynamic")
 echo '{}'
 ;;
 "aarch64-unknown-linux-musl-static")
 echo '{}'
 ;;
 "arm-unknown-linux-gnueabihf")
 echo '{}'
 ;;
 "arm-unknown-linux-musl-dynamiceabihf")
 echo '{}'
 ;;
 "arm-unknown-linux-musl-staticeabihf")
 echo '{}'
 ;;
 "armv7-unknown-linux-gnueabihf")
 echo '{}'
 ;;
 "armv7-unknown-linux-musl-dynamiceabihf")
 echo '{}'
 ;;
 "armv7-unknown-linux-musl-staticeabihf")
 echo '{}'
 ;;
 "i686-pc-windows-gnu")
 echo '{}'
 ;;
 "i686-unknown-linux-gnu")
 echo '{}'
 ;;
 "i686-unknown-linux-musl-dynamic")
 echo '{}'
 ;;
 "i686-unknown-linux-musl-static")
 echo '{}'
 ;;
 "powerpc64-unknown-linux-gnu")
 echo '{}'
 ;;
 "powerpc64le-unknown-linux-gnu")
 echo '{}'
 ;;
 "riscv64gc-unknown-linux-gnu")
 echo '{}'
 ;;
 "s390x-unknown-linux-gnu")
 echo '{}'
 ;;
 "x86\_64-apple-darwin")
 echo '{}'
 ;;
 "x86\_64-pc-windows-gnu")
 echo '{}'
 ;;
 "x86\_64-unknown-linux-gnu")
 echo '{}'
 ;;
 "x86\_64-unknown-linux-musl-dynamic")
 echo '{}'
 ;;
 "x86\_64-unknown-linux-musl-static")
 echo '{}'
 ;;
 \*)
 echo '{}'
 ;;
 esac
}

aliases\_for\_binary() {
 local \_bin="$1"
 local \_arch="$2"

 case "$\_arch" in
 "aarch64-apple-darwin")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "aarch64-pc-windows-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "aarch64-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "aarch64-unknown-linux-musl-dynamic")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "aarch64-unknown-linux-musl-static")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "arm-unknown-linux-gnueabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "arm-unknown-linux-musl-dynamiceabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "arm-unknown-linux-musl-staticeabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "armv7-unknown-linux-gnueabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "armv7-unknown-linux-musl-dynamiceabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "armv7-unknown-linux-musl-staticeabihf")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "i686-pc-windows-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "i686-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "i686-unknown-linux-musl-dynamic")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "i686-unknown-linux-musl-static")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "powerpc64-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "powerpc64le-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "riscv64gc-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "s390x-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "x86\_64-apple-darwin")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "x86\_64-pc-windows-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "x86\_64-unknown-linux-gnu")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "x86\_64-unknown-linux-musl-dynamic")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 "x86\_64-unknown-linux-musl-static")
 case "$\_bin" in
 \*)
 echo ""
 ;;
 esac
 ;;
 \*)
 echo ""
 ;;
 esac
}

select\_archive\_for\_arch() {
 local \_true\_arch="$1"
 local \_archive

 # try each archive, checking runtime conditions like libc versions
 # accepting the first one that matches, as it's the best match
 case "$\_true\_arch" in
 "aarch64-apple-darwin")
 \_archive="uv-aarch64-apple-darwin.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-x86\_64-apple-darwin.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "aarch64-pc-windows-gnu")
 \_archive="uv-aarch64-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "aarch64-pc-windows-msvc")
 \_archive="uv-aarch64-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-x86\_64-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-i686-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "aarch64-unknown-linux-gnu")
 \_archive="uv-aarch64-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "28"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-aarch64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "aarch64-unknown-linux-musl-dynamic")
 \_archive="uv-aarch64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "aarch64-unknown-linux-musl-static")
 \_archive="uv-aarch64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "arm-unknown-linux-gnueabihf")
 \_archive="uv-arm-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "arm-unknown-linux-musl-dynamiceabihf")
 \_archive="uv-arm-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "arm-unknown-linux-musl-staticeabihf")
 \_archive="uv-arm-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "armv7-unknown-linux-gnueabihf")
 \_archive="uv-armv7-unknown-linux-gnueabihf.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-armv7-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "armv7-unknown-linux-musl-dynamiceabihf")
 \_archive="uv-armv7-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "armv7-unknown-linux-musl-staticeabihf")
 \_archive="uv-armv7-unknown-linux-musleabihf.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "i686-pc-windows-gnu")
 \_archive="uv-i686-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "i686-pc-windows-msvc")
 \_archive="uv-i686-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "i686-unknown-linux-gnu")
 \_archive="uv-i686-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-i686-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "i686-unknown-linux-musl-dynamic")
 \_archive="uv-i686-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "i686-unknown-linux-musl-static")
 \_archive="uv-i686-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "powerpc64-unknown-linux-gnu")
 \_archive="uv-powerpc64-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "powerpc64le-unknown-linux-gnu")
 \_archive="uv-powerpc64le-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "riscv64gc-unknown-linux-gnu")
 \_archive="uv-riscv64gc-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "31"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "s390x-unknown-linux-gnu")
 \_archive="uv-s390x-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-apple-darwin")
 \_archive="uv-x86\_64-apple-darwin.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-pc-windows-gnu")
 \_archive="uv-x86\_64-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-pc-windows-msvc")
 \_archive="uv-x86\_64-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-i686-pc-windows-msvc.zip"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-unknown-linux-gnu")
 \_archive="uv-x86\_64-unknown-linux-gnu.tar.gz"
 if ! check\_glibc "2" "17"; then
 \_archive=""
 fi
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 \_archive="uv-x86\_64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-unknown-linux-musl-dynamic")
 \_archive="uv-x86\_64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 "x86\_64-unknown-linux-musl-static")
 \_archive="uv-x86\_64-unknown-linux-musl.tar.gz"
 if \[ -n "$\_archive" \]; then
 echo "$\_archive"
 return 0
 fi
 ;;
 \*)
 err "there isn't a download for your platform $\_true\_arch"
 ;;
 esac
 err "no compatible downloads were found for your platform $\_true\_arch"
}

check\_glibc() {
 local \_min\_glibc\_major="$1"
 local \_min\_glibc\_series="$2"

 # Parsing version out from line 1 like:
 # ldd (Ubuntu GLIBC 2.35-0ubuntu3.1) 2.35
 \_local\_glibc="$(ldd --version \| awk -F' ' '{ if (FNR<=1) print $NF }')"

 if \[ "$(echo "${\_local\_glibc}" \| awk -F. '{ print $1 }')" = "$\_min\_glibc\_major" \] && \[ "$(echo "${\_local\_glibc}" \| awk -F. '{ print $2 }')" -ge "$\_min\_glibc\_series" \]; then
 return 0
 else
 say "System glibc version (\\\`${\_local\_glibc}') is too old; checking alternatives" >&2
 return 1
 fi
}

\# See discussion of late-bound vs early-bound for why we use single-quotes with env vars
\# shellcheck disable=SC2016
install() {
 # This code needs to both compute certain paths for itself to write to, and
 # also write them to shell/rc files so that they can look them up to e.g.
 # add them to PATH. This requires an active distinction between paths
 # and expressions that can compute them.
 #
 # The distinction lies in when we want env-vars to be evaluated. For instance
 # if we determine that we want to install to $HOME/.myapp, which do we add
 # to e.g. $HOME/.profile:
 #
 # \\* early-bound: export PATH="/home/myuser/.myapp:$PATH"
 # \\* late-bound: export PATH="$HOME/.myapp:$PATH"
 #
 # In this case most people would prefer the late-bound version, but in other
 # cases the early-bound version might be a better idea. In particular when using
 # other env-vars than $HOME, they are more likely to be only set temporarily
 # for the duration of this install script, so it's more advisable to erase their
 # existence with early-bounding.
 #
 # This distinction is handled by "double-quotes" (early) vs 'single-quotes' (late).
 #
 # However if we detect that "$SOME\_VAR/..." is a subdir of $HOME, we try to rewrite
 # it to be '$HOME/...' to get the best of both worlds.
 #
 # This script has a few different variants, the most complex one being the
 # CARGO\_HOME version which attempts to install things to Cargo's bin dir,
 # potentially setting up a minimal version if the user hasn't ever installed Cargo.
 #
 # In this case we need to:
 #
 # \\* Install to $HOME/.cargo/bin/
 # \\* Create a shell script at $HOME/.cargo/env that:
 # \\* Checks if $HOME/.cargo/bin/ is on PATH
 # \\* and if not prepends it to PATH
 # \\* Edits $INFERRED\_HOME/.profile to run $HOME/.cargo/env (if the line doesn't exist)
 #
 # To do this we need these 4 values:

 # The actual path we're going to install to
 local \_install\_dir
 # The directory C dynamic/static libraries install to
 local \_lib\_install\_dir
 # The install prefix we write to the receipt.
 # For organized install methods like CargoHome, which have
 # subdirectories, this is the root without \`/bin\`. For other
 # methods, this is the same as \`\_install\_dir\`.
 local \_receipt\_install\_dir
 # Path to the an shell script that adds install\_dir to PATH
 local \_env\_script\_path
 # Potentially-late-bound version of install\_dir to write env\_script
 local \_install\_dir\_expr
 # Potentially-late-bound version of env\_script\_path to write to rcfiles like $HOME/.profile
 local \_env\_script\_path\_expr
 # Forces the install to occur at this path, not the default
 local \_force\_install\_dir
 # Which install layout to use - "flat" or "hierarchical"
 local \_install\_layout="unspecified"
 # A list of binaries which are shadowed in the PATH
 local \_shadowed\_bins=""

 # Check the newer app-specific variable before falling back
 # to the older generic one
 if \[ -n "${UV\_INSTALL\_DIR:-}" \]; then
 \_force\_install\_dir="$UV\_INSTALL\_DIR"
 \_install\_layout="flat"
 elif \[ -n "${CARGO\_DIST\_FORCE\_INSTALL\_DIR:-}" \]; then
 \_force\_install\_dir="$CARGO\_DIST\_FORCE\_INSTALL\_DIR"
 \_install\_layout="flat"
 elif \[ -n "$UNMANAGED\_INSTALL" \]; then
 \_force\_install\_dir="$UNMANAGED\_INSTALL"
 \_install\_layout="flat"
 fi

 # Check if the install layout should be changed from \`flat\` to \`cargo-home\`
 # for backwards compatible updates of applications that switched layouts.
 if \[ -n "${\_force\_install\_dir:-}" \]; then
 if \[ "$\_install\_layout" = "flat" \]; then
 # If the install directory is targeting the Cargo home directory, then
 # we assume this application was previously installed that layout
 if \[ "$\_force\_install\_dir" = "${CARGO\_HOME:-${INFERRED\_HOME:-}/.cargo}" \]; then
 \_install\_layout="cargo-home"
 fi
 fi
 fi

 # Before actually consulting the configured install strategy, see
 # if we're overriding it.
 if \[ -n "${\_force\_install\_dir:-}" \]; then
 case "$\_install\_layout" in
 "hierarchical")
 \_install\_dir="$\_force\_install\_dir/bin"
 \_lib\_install\_dir="$\_force\_install\_dir/lib"
 \_receipt\_install\_dir="$\_force\_install\_dir"
 \_env\_script\_path="$\_force\_install\_dir/env"
 \_install\_dir\_expr="$(replace\_home "$\_force\_install\_dir/bin")"
 \_env\_script\_path\_expr="$(replace\_home "$\_force\_install\_dir/env")"
 ;;
 "cargo-home")
 \_install\_dir="$\_force\_install\_dir/bin"
 \_lib\_install\_dir="$\_force\_install\_dir/bin"
 \_receipt\_install\_dir="$\_force\_install\_dir"
 \_env\_script\_path="$\_force\_install\_dir/env"
 \_install\_dir\_expr="$(replace\_home "$\_force\_install\_dir/bin")"
 \_env\_script\_path\_expr="$(replace\_home "$\_force\_install\_dir/env")"
 ;;
 "flat")
 \_install\_dir="$\_force\_install\_dir"
 \_lib\_install\_dir="$\_force\_install\_dir"
 \_receipt\_install\_dir="$\_install\_dir"
 \_env\_script\_path="$\_force\_install\_dir/env"
 \_install\_dir\_expr="$(replace\_home "$\_force\_install\_dir")"
 \_env\_script\_path\_expr="$(replace\_home "$\_force\_install\_dir/env")"
 ;;
 \*)
 err "Unrecognized install layout: $\_install\_layout"
 ;;
 esac
 fi
 if \[ -z "${\_install\_dir:-}" \]; then
 \_install\_layout="flat"
 # Install to $XDG\_BIN\_HOME
 if \[ -n "${XDG\_BIN\_HOME:-}" \]; then
 \_install\_dir="$XDG\_BIN\_HOME"
 \_lib\_install\_dir="$\_install\_dir"
 \_receipt\_install\_dir="$\_install\_dir"
 \_env\_script\_path="$XDG\_BIN\_HOME/env"
 \_install\_dir\_expr="$(replace\_home "$\_install\_dir")"
 \_env\_script\_path\_expr="$(replace\_home "$\_env\_script\_path")"
 fi
 fi
 if \[ -z "${\_install\_dir:-}" \]; then
 \_install\_layout="flat"
 # Install to $XDG\_DATA\_HOME/../bin
 if \[ -n "${XDG\_DATA\_HOME:-}" \]; then
 \_install\_dir="$XDG\_DATA\_HOME/../bin"
 \_lib\_install\_dir="$\_install\_dir"
 \_receipt\_install\_dir="$\_install\_dir"
 \_env\_script\_path="$XDG\_DATA\_HOME/../bin/env"
 \_install\_dir\_expr="$(replace\_home "$\_install\_dir")"
 \_env\_script\_path\_expr="$(replace\_home "$\_env\_script\_path")"
 fi
 fi
 if \[ -z "${\_install\_dir:-}" \]; then
 \_install\_layout="flat"
 # Install to $HOME/.local/bin
 if \[ -n "${INFERRED\_HOME:-}" \]; then
 \_install\_dir="$INFERRED\_HOME/.local/bin"
 \_lib\_install\_dir="$INFERRED\_HOME/.local/bin"
 \_receipt\_install\_dir="$\_install\_dir"
 \_env\_script\_path="$INFERRED\_HOME/.local/bin/env"
 \_install\_dir\_expr="$INFERRED\_HOME\_EXPRESSION/.local/bin"
 \_env\_script\_path\_expr="$INFERRED\_HOME\_EXPRESSION/.local/bin/env"
 fi
 fi

 if \[ -z "$\_install\_dir\_expr" \]; then
 err "could not find a valid path to install to!"
 fi

 # Identical to the sh version, just with a .fish file extension
 # We place it down here to wait until it's been assigned in every
 # path.
 \_fish\_env\_script\_path="${\_env\_script\_path}.fish"
 \_fish\_env\_script\_path\_expr="${\_env\_script\_path\_expr}.fish"

 # Replace the temporary cargo home with the calculated one
 RECEIPT=$(echo "$RECEIPT" \| sed "s,AXO\_INSTALL\_PREFIX,$\_receipt\_install\_dir,")
 # Also replace the aliases with the arch-specific one
 RECEIPT=$(echo "$RECEIPT" \| sed "s'\\"binary\_aliases\\":{}'\\"binary\_aliases\\":$(json\_binary\_aliases "$\_arch")'")
 # And replace the install layout
 RECEIPT=$(echo "$RECEIPT" \| sed "s'\\"install\_layout\\":\\"unspecified\\"'\\"install\_layout\\":\\"$\_install\_layout\\"'")
 if \[ "$NO\_MODIFY\_PATH" = "1" \]; then
 RECEIPT=$(echo "$RECEIPT" \| sed "s'\\"modify\_path\\":true'\\"modify\_path\\":false'")
 fi

 say "installing to $\_install\_dir"
 ensure mkdir -p "$\_install\_dir"
 ensure mkdir -p "$\_lib\_install\_dir"

 # copy all the binaries to the install dir
 local \_src\_dir="$1"
 local \_bins="$2"
 local \_libs="$3"
 local \_staticlibs="$4"
 local \_arch="$5"
 for \_bin\_name in $\_bins; do
 local \_bin="$\_src\_dir/$\_bin\_name"
 ensure mv "$\_bin" "$\_install\_dir"
 # unzip seems to need this chmod
 ensure chmod +x "$\_install\_dir/$\_bin\_name"
 for \_dest in $(aliases\_for\_binary "$\_bin\_name" "$\_arch"); do
 ln -sf "$\_install\_dir/$\_bin\_name" "$\_install\_dir/$\_dest"
 done
 say " $\_bin\_name"
 done
 # Like the above, but no aliases
 for \_lib\_name in $\_libs; do
 local \_lib="$\_src\_dir/$\_lib\_name"
 ensure mv "$\_lib" "$\_lib\_install\_dir"
 # unzip seems to need this chmod
 ensure chmod +x "$\_lib\_install\_dir/$\_lib\_name"
 say " $\_lib\_name"
 done
 for \_lib\_name in $\_staticlibs; do
 local \_lib="$\_src\_dir/$\_lib\_name"
 ensure mv "$\_lib" "$\_lib\_install\_dir"
 # unzip seems to need this chmod
 ensure chmod +x "$\_lib\_install\_dir/$\_lib\_name"
 say " $\_lib\_name"
 done

 say "everything's installed!"

 # Avoid modifying the users PATH if they are managing their PATH manually
 case :$PATH:
 in \*:$\_install\_dir:\*) NO\_MODIFY\_PATH=1 ;;
 \*) ;;
 esac

 if \[ "0" = "$NO\_MODIFY\_PATH" \]; then
 add\_install\_dir\_to\_ci\_path "$\_install\_dir"
 add\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_env\_script\_path" "$\_env\_script\_path\_expr" ".profile" "sh"
 exit1=$?
 shotgun\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_env\_script\_path" "$\_env\_script\_path\_expr" ".profile .bashrc .bash\_profile .bash\_login" "sh"
 exit2=$?
 add\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_env\_script\_path" "$\_env\_script\_path\_expr" ".zshrc .zshenv" "sh"
 exit3=$?
 # This path may not exist by default
 ensure mkdir -p "$INFERRED\_HOME/.config/fish/conf.d"
 exit4=$?
 add\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_fish\_env\_script\_path" "$\_fish\_env\_script\_path\_expr" ".config/fish/conf.d/$APP\_NAME.env.fish" "fish"
 exit5=$?

 if \[ "${exit1:-0}" = 1 \] \|\| \[ "${exit2:-0}" = 1 \] \|\| \[ "${exit3:-0}" = 1 \] \|\| \[ "${exit4:-0}" = 1 \] \|\| \[ "${exit5:-0}" = 1 \]; then
 say ""
 say "To add $\_install\_dir\_expr to your PATH, either restart your shell or run:"
 say ""
 say " source $\_env\_script\_path\_expr (sh, bash, zsh)"
 say " source $\_fish\_env\_script\_path\_expr (fish)"
 fi
 fi

 \_shadowed\_bins="$(check\_for\_shadowed\_bins "$\_install\_dir" "$\_bins")"
 if \[ -n "$\_shadowed\_bins" \]; then
 warn "The following commands are shadowed by other commands in your PATH:$\_shadowed\_bins"
 fi
}

check\_for\_shadowed\_bins() {
 local \_install\_dir="$1"
 local \_bins="$2"
 local \_shadow

 for \_bin\_name in $\_bins; do
 \_shadow="$(command -v "$\_bin\_name")"
 if \[ -n "$\_shadow" \] && \[ "$\_shadow" != "$\_install\_dir/$\_bin\_name" \]; then
 \_shadowed\_bins="$\_shadowed\_bins $\_bin\_name"
 fi
 done

 echo "$\_shadowed\_bins"
}

print\_home\_for\_script() {
 local script="$1"

 local \_home
 case "$script" in
 # zsh has a special ZDOTDIR directory, which if set
 # should be considered instead of $HOME
 .zsh\*)
 if \[ -n "${ZDOTDIR:-}" \]; then
 \_home="$ZDOTDIR"
 else
 \_home="$INFERRED\_HOME"
 fi
 ;;
 \*)
 \_home="$INFERRED\_HOME"
 ;;
 esac

 echo "$\_home"
}

add\_install\_dir\_to\_ci\_path() {
 # Attempt to do CI-specific rituals to get the install-dir on PATH faster
 local \_install\_dir="$1"

 # If GITHUB\_PATH is present, then write install\_dir to the file it refs.
 # After each GitHub Action, the contents will be added to PATH.
 # So if you put a curl \| sh for this script in its own "run" step,
 # the next step will have this dir on PATH.
 #
 # Note that GITHUB\_PATH will not resolve any variables, so we in fact
 # want to write install\_dir and not install\_dir\_expr
 if \[ -n "${GITHUB\_PATH:-}" \]; then
 ensure echo "$\_install\_dir" >> "$GITHUB\_PATH"
 fi
}

add\_install\_dir\_to\_path() {
 # Edit rcfiles ($HOME/.profile) to add install\_dir to $PATH
 #
 # We do this slightly indirectly by creating an "env" shell script which checks if install\_dir
 # is on $PATH already, and prepends it if not. The actual line we then add to rcfiles
 # is to just source that script. This allows us to blast it into lots of different rcfiles and
 # have it run multiple times without causing problems. It's also specifically compatible
 # with the system rustup uses, so that we don't conflict with it.
 local \_install\_dir\_expr="$1"
 local \_env\_script\_path="$2"
 local \_env\_script\_path\_expr="$3"
 local \_rcfiles="$4"
 local \_shell="$5"

 if \[ -n "${INFERRED\_HOME:-}" \]; then
 local \_target
 local \_home

 # Find the first file in the array that exists and choose
 # that as our target to write to
 for \_rcfile\_relative in $\_rcfiles; do
 \_home="$(print\_home\_for\_script "$\_rcfile\_relative")"
 local \_rcfile="$\_home/$\_rcfile\_relative"

 if \[ -f "$\_rcfile" \]; then
 \_target="$\_rcfile"
 break
 fi
 done

 # If we didn't find anything, pick the first entry in the
 # list as the default to create and write to
 if \[ -z "${\_target:-}" \]; then
 local \_rcfile\_relative
 \_rcfile\_relative="$(echo "$\_rcfiles" \| awk '{ print $1 }')"
 \_home="$(print\_home\_for\_script "$\_rcfile\_relative")"
 \_target="$\_home/$\_rcfile\_relative"
 fi

 # \`source x\` is an alias for \`. x\`, and the latter is more portable/actually-posix.
 # This apparently comes up a lot on freebsd. It's easy enough to always add
 # the more robust line to rcfiles, but when telling the user to apply the change
 # to their current shell ". x" is pretty easy to misread/miscopy, so we use the
 # prettier "source x" line there. Hopefully people with Weird Shells are aware
 # this is a thing and know to tweak it (or just restart their shell).
 local \_robust\_line=". \\"$\_env\_script\_path\_expr\\""
 local \_pretty\_line="source \\"$\_env\_script\_path\_expr\\""

 # Add the env script if it doesn't already exist
 if \[ ! -f "$\_env\_script\_path" \]; then
 say\_verbose "creating $\_env\_script\_path"
 if \[ "$\_shell" = "sh" \]; then
 write\_env\_script\_sh "$\_install\_dir\_expr" "$\_env\_script\_path"
 else
 write\_env\_script\_fish "$\_install\_dir\_expr" "$\_env\_script\_path"
 fi
 else
 say\_verbose "$\_env\_script\_path already exists"
 fi

 # Check if the line is already in the rcfile
 # grep: 0 if matched, 1 if no match, and 2 if an error occurred
 #
 # Ideally we could use quiet grep (-q), but that makes "match" and "error"
 # have the same behaviour, when we want "no match" and "error" to be the same
 # (on error we want to create the file, which >> conveniently does)
 #
 # We search for both kinds of line here just to do the right thing in more cases.
 if ! grep -F "$\_robust\_line" "$\_target" > /dev/null 2>/dev/null && \
 ! grep -F "$\_pretty\_line" "$\_target" > /dev/null 2>/dev/null
 then
 # If the script now exists, add the line to source it to the rcfile
 # (This will also create the rcfile if it doesn't exist)
 if \[ -f "$\_env\_script\_path" \]; then
 local \_line
 # Fish has deprecated \`.\` as an alias for \`source\` and
 # it will be removed in a later version.
 # https://fishshell.com/docs/current/cmds/source.html
 # By contrast, \`.\` is the traditional syntax in sh and
 # \`source\` isn't always supported in all circumstances.
 if \[ "$\_shell" = "fish" \]; then
 \_line="$\_pretty\_line"
 else
 \_line="$\_robust\_line"
 fi
 say\_verbose "adding $\_line to $\_target"
 # prepend an extra newline in case the user's file is missing a trailing one
 ensure echo "" >> "$\_target"
 ensure echo "$\_line" >> "$\_target"
 return 1
 fi
 else
 say\_verbose "$\_install\_dir already on PATH"
 fi
 fi
}

shotgun\_install\_dir\_to\_path() {
 # Edit rcfiles ($HOME/.profile) to add install\_dir to $PATH
 # (Shotgun edition - write to all provided files that exist rather than just the first)
 local \_install\_dir\_expr="$1"
 local \_env\_script\_path="$2"
 local \_env\_script\_path\_expr="$3"
 local \_rcfiles="$4"
 local \_shell="$5"

 if \[ -n "${INFERRED\_HOME:-}" \]; then
 local \_found=false
 local \_home

 for \_rcfile\_relative in $\_rcfiles; do
 \_home="$(print\_home\_for\_script "$\_rcfile\_relative")"
 local \_rcfile\_abs="$\_home/$\_rcfile\_relative"

 if \[ -f "$\_rcfile\_abs" \]; then
 \_found=true
 add\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_env\_script\_path" "$\_env\_script\_path\_expr" "$\_rcfile\_relative" "$\_shell"
 fi
 done

 # Fall through to previous "create + write to first file in list" behavior
 if \[ "$\_found" = false \]; then
 add\_install\_dir\_to\_path "$\_install\_dir\_expr" "$\_env\_script\_path" "$\_env\_script\_path\_expr" "$\_rcfiles" "$\_shell"
 fi
 fi
}

write\_env\_script\_sh() {
 # write this env script to the given path (this cat/EOF stuff is a "heredoc" string)
 local \_install\_dir\_expr="$1"
 local \_env\_script\_path="$2"
 ensure cat < "$\_env\_script\_path"
#!/bin/sh
\# add binaries to PATH if they aren't added yet
\# affix colons on either side of \\$PATH to simplify matching
case ":\\${PATH}:" in
 \*:"$\_install\_dir\_expr":\*)
 ;;
 \*)
 # Prepending path in case a system-installed binary needs to be overridden
 export PATH="$\_install\_dir\_expr:\\$PATH"
 ;;
esac
EOF
}

write\_env\_script\_fish() {
 # write this env script to the given path (this cat/EOF stuff is a "heredoc" string)
 local \_install\_dir\_expr="$1"
 local \_env\_script\_path="$2"
 ensure cat < "$\_env\_script\_path"
if not contains "$\_install\_dir\_expr" \\$PATH
 # Prepending path in case a system-installed binary needs to be overridden
 set -x PATH "$\_install\_dir\_expr" \\$PATH
end
EOF
}

get\_current\_exe() {
 # Returns the executable used for system architecture detection
 # This is only run on Linux
 local \_current\_exe
 if test -L /proc/self/exe ; then
 \_current\_exe=/proc/self/exe
 else
 warn "Unable to find /proc/self/exe. System architecture detection might be inaccurate."
 if test -n "$SHELL" ; then
 \_current\_exe=$SHELL
 else
 need\_cmd /bin/sh
 \_current\_exe=/bin/sh
 fi
 warn "Falling back to $\_current\_exe."
 fi
 echo "$\_current\_exe"
}

get\_bitness() {
 need\_cmd head
 # Architecture detection without dependencies beyond coreutils.
 # ELF files start out "\\x7fELF", and the following byte is
 # 0x01 for 32-bit and
 # 0x02 for 64-bit.
 # The printf builtin on some shells like dash only supports octal
 # escape sequences, so we use those.
 local \_current\_exe=$1
 local \_current\_exe\_head
 \_current\_exe\_head=$(head -c 5 "$\_current\_exe")
 if \[ "$\_current\_exe\_head" = "$(printf '\\177ELF\\001')" \]; then
 echo 32
 elif \[ "$\_current\_exe\_head" = "$(printf '\\177ELF\\002')" \]; then
 echo 64
 else
 err "unknown platform bitness"
 fi
}

is\_host\_amd64\_elf() {
 local \_current\_exe=$1

 need\_cmd head
 need\_cmd tail
 # ELF e\_machine detection without dependencies beyond coreutils.
 # Two-byte field at offset 0x12 indicates the CPU,
 # but we're interested in it being 0x3E to indicate amd64, or not that.
 local \_current\_exe\_machine
 \_current\_exe\_machine=$(head -c 19 "$\_current\_exe" \| tail -c 1)
 \[ "$\_current\_exe\_machine" = "$(printf '\\076')" \]
}

get\_endianness() {
 local \_current\_exe=$1
 local cputype=$2
 local suffix\_eb=$3
 local suffix\_el=$4

 # detect endianness without od/hexdump, like get\_bitness() does.
 need\_cmd head
 need\_cmd tail

 local \_current\_exe\_endianness
 \_current\_exe\_endianness="$(head -c 6 "$\_current\_exe" \| tail -c 1)"
 if \[ "$\_current\_exe\_endianness" = "$(printf '\\001')" \]; then
 echo "${cputype}${suffix\_el}"
 elif \[ "$\_current\_exe\_endianness" = "$(printf '\\002')" \]; then
 echo "${cputype}${suffix\_eb}"
 else
 err "unknown platform endianness"
 fi
}

\# Detect the Linux/LoongArch UAPI flavor, with all errors being non-fatal.
\# Returns 0 or 234 in case of successful detection, 1 otherwise (/tmp being
\# noexec, or other causes).
check\_loongarch\_uapi() {
 need\_cmd base64

 local \_tmp
 if ! \_tmp="$(ensure mktemp)"; then
 return 1
 fi

 # Minimal Linux/LoongArch UAPI detection, exiting with 0 in case of
 # upstream ("new world") UAPI, and 234 (-EINVAL truncated) in case of
 # old-world (as deployed on several early commercial Linux distributions
 # for LoongArch).
 #
 # See https://gist.github.com/xen0n/5ee04aaa6cecc5c7794b9a0c3b65fc7f for
 # source to this helper binary.
 ignore base64 -d > "$\_tmp" <&1 \| grep -q 'musl'; then
 \_clibtype="musl-dynamic"
 else
 # Assume all other linuxes are glibc (even if wrong, static libc fallback will apply)
 \_clibtype="gnu"
 fi
 fi

 if \[ "$\_ostype" = Darwin \]; then
 # Darwin \`uname -m\` can lie due to Rosetta shenanigans. If you manage to
 # invoke a native shell binary and then a native uname binary, you can
 # get the real answer, but that's hard to ensure, so instead we use
 # \`sysctl\` (which doesn't lie) to check for the actual architecture.
 if \[ "$\_cputype" = i386 \]; then
 # Handling i386 compatibility mode in older macOS versions (<10.15)
 # running on x86\_64-based Macs.
 # Starting from 10.15, macOS explicitly bans all i386 binaries from running.
 # See:

 # Avoid \`sysctl: unknown oid\` stderr output and/or non-zero exit code.
 if sysctl hw.optional.x86\_64 2> /dev/null \|\| true \| grep -q ': 1'; then
 \_cputype=x86\_64
 fi
 elif \[ "$\_cputype" = x86\_64 \]; then
 # Handling x86-64 compatibility mode (a.k.a. Rosetta 2)
 # in newer macOS versions (>=11) running on arm64-based Macs.
 # Rosetta 2 is built exclusively for x86-64 and cannot run i386 binaries.

 # Avoid \`sysctl: unknown oid\` stderr output and/or non-zero exit code.
 if sysctl hw.optional.arm64 2> /dev/null \|\| true \| grep -q ': 1'; then
 \_cputype=arm64
 fi
 fi
 fi

 if \[ "$\_ostype" = SunOS \]; then
 # Both Solaris and illumos presently announce as "SunOS" in "uname -s"
 # so use "uname -o" to disambiguate. We use the full path to the
 # system uname in case the user has coreutils uname first in PATH,
 # which has historically sometimes printed the wrong value here.
 if \[ "$(/usr/bin/uname -o)" = illumos \]; then
 \_ostype=illumos
 fi

 # illumos systems have multi-arch userlands, and "uname -m" reports the
 # machine hardware name; e.g., "i86pc" on both 32- and 64-bit x86
 # systems. Check for the native (widest) instruction set on the
 # running kernel:
 if \[ "$\_cputype" = i86pc \]; then
 \_cputype="$(isainfo -n)"
 fi
 fi

 local \_current\_exe
 case "$\_ostype" in

 Android)
 \_ostype=linux-android
 ;;

 Linux)
 \_current\_exe=$(get\_current\_exe)
 \_ostype=unknown-linux-$\_clibtype
 \_bitness=$(get\_bitness "$\_current\_exe")
 ;;

 FreeBSD)
 \_ostype=unknown-freebsd
 ;;

 NetBSD)
 \_ostype=unknown-netbsd
 ;;

 DragonFly)
 \_ostype=unknown-dragonfly
 ;;

 Darwin)
 \_ostype=apple-darwin
 ;;

 illumos)
 \_ostype=unknown-illumos
 ;;

 MINGW\* \| MSYS\* \| CYGWIN\* \| Windows\_NT)
 \_ostype=pc-windows-gnu
 ;;

 \*)
 err "unrecognized OS type: $\_ostype"
 ;;

 esac

 case "$\_cputype" in

 i386 \| i486 \| i686 \| i786 \| x86)
 \_cputype=i686
 ;;

 xscale \| arm)
 \_cputype=arm
 if \[ "$\_ostype" = "linux-android" \]; then
 \_ostype=linux-androideabi
 fi
 ;;

 armv6l)
 \_cputype=arm
 if \[ "$\_ostype" = "linux-android" \]; then
 \_ostype=linux-androideabi
 else
 \_ostype="${\_ostype}eabihf"
 fi
 ;;

 armv7l \| armv8l)
 \_cputype=armv7
 if \[ "$\_ostype" = "linux-android" \]; then
 \_ostype=linux-androideabi
 else
 \_ostype="${\_ostype}eabihf"
 fi
 ;;

 aarch64 \| arm64)
 \_cputype=aarch64
 ;;

 x86\_64 \| x86-64 \| x64 \| amd64)
 \_cputype=x86\_64
 ;;

 mips)
 \_cputype=$(get\_endianness "$\_current\_exe" mips '' el)
 ;;

 mips64)
 if \[ "$\_bitness" -eq 64 \]; then
 # only n64 ABI is supported for now
 \_ostype="${\_ostype}abi64"
 \_cputype=$(get\_endianness "$\_current\_exe" mips64 '' el)
 fi
 ;;

 ppc)
 \_cputype=powerpc
 ;;

 ppc64)
 \_cputype=powerpc64
 ;;

 ppc64le)
 \_cputype=powerpc64le
 ;;

 s390x)
 \_cputype=s390x
 ;;
 riscv64)
 \_cputype=riscv64gc
 ;;
 loongarch64)
 \_cputype=loongarch64
 ensure\_loongarch\_uapi
 ;;
 \*)
 err "unknown CPU type: $\_cputype"

 esac

 # Detect 64-bit linux with 32-bit userland
 if \[ "${\_ostype}" = unknown-linux-gnu \] && \[ "${\_bitness}" -eq 32 \]; then
 case $\_cputype in
 x86\_64)
 # 32-bit executable for amd64 = x32
 if is\_host\_amd64\_elf "$\_current\_exe"; then {
 err "x32 linux unsupported"
 }; else
 \_cputype=i686
 fi
 ;;
 mips64)
 \_cputype=$(get\_endianness "$\_current\_exe" mips '' el)
 ;;
 powerpc64)
 \_cputype=powerpc
 ;;
 aarch64)
 \_cputype=armv7
 if \[ "$\_ostype" = "linux-android" \]; then
 \_ostype=linux-androideabi
 else
 \_ostype="${\_ostype}eabihf"
 fi
 ;;
 riscv64gc)
 err "riscv64 with 32-bit userland unsupported"
 ;;
 esac
 fi

 # Detect armv7 but without the CPU features Rust needs in that build,
 # and fall back to arm.
 if \[ "$\_ostype" = "unknown-linux-gnueabihf" \] && \[ "$\_cputype" = armv7 \]; then
 if ! (ensure grep '^Features' /proc/cpuinfo \| grep -E -q 'neon\|simd') ; then
 # Either \`/proc/cpuinfo\` is malformed or unavailable, or
 # at least one processor does not have NEON (which is asimd on armv8+).
 \_cputype=arm
 fi
 fi

 \_arch="${\_cputype}-${\_ostype}"

 RETVAL="$\_arch"
}

say() {
 if \[ "0" = "$PRINT\_QUIET" \]; then
 echo "$1"
 fi
}

say\_verbose() {
 if \[ "1" = "$PRINT\_VERBOSE" \]; then
 echo "$1"
 fi
}

warn() {
 if \[ "0" = "$PRINT\_QUIET" \]; then
 local red
 local reset
 red=$(tput setaf 1 2>/dev/null \|\| echo '')
 reset=$(tput sgr0 2>/dev/null \|\| echo '')
 say "${red}WARN${reset}: $1" >&2
 fi
}

err() {
 if \[ "0" = "$PRINT\_QUIET" \]; then
 local red
 local reset
 red=$(tput setaf 1 2>/dev/null \|\| echo '')
 reset=$(tput sgr0 2>/dev/null \|\| echo '')
 say "${red}ERROR${reset}: $1" >&2
 fi
 exit 1
}

need\_cmd() {
 if ! check\_cmd "$1"
 then err "need '$1' (command not found)"
 fi
}

check\_cmd() {
 command -v "$1" > /dev/null 2>&1
 return $?
}

assert\_nz() {
 if \[ -z "$1" \]; then err "assert\_nz $2"; fi
}

\# Run a command that should never fail. If the command fails execution
\# will immediately terminate with an error showing the failing
\# command.
ensure() {
 if ! "$@"; then err "command failed: $\*"; fi
}

\# This is just for indicating that commands' results are being
\# intentionally ignored. Usually, because it's being executed
\# as part of error handling.
ignore() {
 "$@"
}

\# This wraps curl or wget. Try curl first, if not installed,
\# use wget instead.
downloader() {
 # Check if we have a broken snap curl
 # https://github.com/boukendesho/curl-snap/issues/1
 \_snap\_curl=0
 if command -v curl > /dev/null 2>&1; then
 \_curl\_path=$(command -v curl)
 if echo "$\_curl\_path" \| grep "/snap/" > /dev/null 2>&1; then
 \_snap\_curl=1
 fi
 fi

 # Check if we have a working (non-snap) curl
 if check\_cmd curl && \[ "$\_snap\_curl" = "0" \]
 then \_dld=curl
 # Try wget for both no curl and the broken snap curl
 elif check\_cmd wget
 then \_dld=wget
 # If we can't fall back from broken snap curl to wget, report the broken snap curl
 elif \[ "$\_snap\_curl" = "1" \]
 then
 say "curl installed with snap cannot be used to install $APP\_NAME"
 say "due to missing permissions. Please uninstall it and"
 say "reinstall curl with a different package manager (e.g., apt)."
 say "See https://github.com/boukendesho/curl-snap/issues/1"
 exit 1
 else \_dld='curl or wget' # to be used in error message of need\_cmd
 fi

 if \[ "$1" = --check \]
 then need\_cmd "$\_dld"
 elif \[ "$\_dld" = curl \]; then
 if \[ -n "${AUTH\_TOKEN:-}" \]; then
 curl -sSfL --header "Authorization: Bearer ${AUTH\_TOKEN}" "$1" -o "$2"
 else
 curl -sSfL "$1" -o "$2"
 fi
 elif \[ "$\_dld" = wget \]; then
 if \[ -n "${AUTH\_TOKEN:-}" \]; then
 wget --header "Authorization: Bearer ${AUTH\_TOKEN}" "$1" -O "$2"
 else
 wget "$1" -O "$2"
 fi
 else err "Unknown downloader" # should not reach here
 fi
}

verify\_checksum() {
 local \_file="$1"
 local \_checksum\_style="$2"
 local \_checksum\_value="$3"
 local \_calculated\_checksum

 if \[ -z "$\_checksum\_value" \]; then
 return 0
 fi
 case "$\_checksum\_style" in
 sha256)
 if ! check\_cmd sha256sum; then
 say "skipping sha256 checksum verification (it requires the 'sha256sum' command)"
 return 0
 fi
 \_calculated\_checksum="$(sha256sum -b "$\_file" \| awk '{printf $1}')"
 ;;
 sha512)
 if ! check\_cmd sha512sum; then
 say "skipping sha512 checksum verification (it requires the 'sha512sum' command)"
 return 0
 fi
 \_calculated\_checksum="$(sha512sum -b "$\_file" \| awk '{printf $1}')"
 ;;
 sha3-256)
 if ! check\_cmd openssl; then
 say "skipping sha3-256 checksum verification (it requires the 'openssl' command)"
 return 0
 fi
 \_calculated\_checksum="$(openssl dgst -sha3-256 "$\_file" \| awk '{printf $NF}')"
 ;;
 sha3-512)
 if ! check\_cmd openssl; then
 say "skipping sha3-512 checksum verification (it requires the 'openssl' command)"
 return 0
 fi
 \_calculated\_checksum="$(openssl dgst -sha3-512 "$\_file" \| awk '{printf $NF}')"
 ;;
 blake2s)
 if ! check\_cmd b2sum; then
 say "skipping blake2s checksum verification (it requires the 'b2sum' command)"
 return 0
 fi
 # Test if we have official b2sum with blake2s support
 local \_well\_known\_blake2s\_checksum="93314a61f470985a40f8da62df10ba0546dc5216e1d45847bf1dbaa42a0e97af"
 local \_test\_blake2s
 \_test\_blake2s="$(printf "can do blake2s" \| b2sum -a blake2s \| awk '{printf $1}')" \|\| \_test\_blake2s=""

 if \[ "X$\_test\_blake2s" = "X$\_well\_known\_blake2s\_checksum" \]; then
 \_calculated\_checksum="$(b2sum -a blake2s "$\_file" \| awk '{printf $1}')" \|\| \_calculated\_checksum=""
 else
 say "skipping blake2s checksum verification (installed b2sum doesn't support blake2s)"
 return 0
 fi
 ;;
 blake2b)
 if ! check\_cmd b2sum; then
 say "skipping blake2b checksum verification (it requires the 'b2sum' command)"
 return 0
 fi
 \_calculated\_checksum="$(b2sum "$\_file" \| awk '{printf $1}')"
 ;;
 false)
 ;;
 \*)
 say "skipping unknown checksum style: $\_checksum\_style"
 return 0
 ;;
 esac

 if \[ "$\_calculated\_checksum" != "$\_checksum\_value" \]; then
 err "checksum mismatch
 want: $\_checksum\_value
 got: $\_calculated\_checksum"
 fi
}

download\_binary\_and\_run\_installer "$@" \|\| exit 1